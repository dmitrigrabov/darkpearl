import { createSupabaseClient, createServiceClient } from '../_shared/supabase-client.ts';
import { handleCors } from '../_shared/cors.ts';
import {
  jsonResponse,
  errorResponse,
  notFoundResponse,
  methodNotAllowedResponse,
} from '../_shared/response.ts';
import type { CreateOrderRequest, Order, OrderItem } from '../_shared/types.ts';

Deno.serve(async (req) => {
  // Handle CORS preflight
  const corsResponse = handleCors(req);
  if (corsResponse) return corsResponse;

  const url = new URL(req.url);
  const method = req.method;

  // Extract order ID from path if present: /orders/{id}
  const pathParts = url.pathname.split('/').filter(Boolean);
  const orderId = pathParts.length > 1 ? pathParts[1] : null;

  try {
    const client = createSupabaseClient(req);
    const serviceClient = createServiceClient();

    switch (method) {
      case 'GET': {
        if (orderId) {
          // Get single order with items and saga status
          const { data: order, error } = await client
            .from('orders')
            .select(`
              *,
              items:order_items(
                id, product_id, quantity, unit_price,
                product:products(id, sku, name)
              ),
              warehouse:warehouses(id, code, name)
            `)
            .eq('id', orderId)
            .single();

          if (error || !order) {
            return notFoundResponse('Order');
          }

          // Get saga status if exists
          const { data: saga } = await serviceClient
            .from('sagas')
            .select('id, status, current_step, error_message, created_at, completed_at')
            .eq('correlation_id', orderId)
            .single();

          return jsonResponse({ ...order, saga: saga || null });
        } else {
          // List orders
          const status = url.searchParams.get('status');
          const customerId = url.searchParams.get('customer_id');
          const limit = parseInt(url.searchParams.get('limit') || '100');
          const offset = parseInt(url.searchParams.get('offset') || '0');

          let query = client.from('orders').select(
            `
              *,
              warehouse:warehouses(id, code, name)
            `,
            { count: 'exact' }
          );

          if (status) {
            query = query.eq('status', status);
          }
          if (customerId) {
            query = query.eq('customer_id', customerId);
          }

          const { data, error, count } = await query
            .order('created_at', { ascending: false })
            .range(offset, offset + limit - 1);

          if (error) throw error;
          return jsonResponse({ data, count, limit, offset });
        }
      }

      case 'POST': {
        const body: CreateOrderRequest = await req.json();

        // Validate required fields
        if (!body.warehouse_id || !body.items || body.items.length === 0) {
          return errorResponse('warehouse_id and at least one item are required');
        }

        // Validate warehouse exists
        const { data: warehouse } = await serviceClient
          .from('warehouses')
          .select('id')
          .eq('id', body.warehouse_id)
          .single();

        if (!warehouse) {
          return errorResponse('Warehouse not found', 404);
        }

        // Validate all products exist and calculate total
        let totalAmount = 0;
        for (const item of body.items) {
          if (!item.product_id || !item.quantity || item.quantity <= 0) {
            return errorResponse('Each item must have product_id and positive quantity');
          }

          const { data: product } = await serviceClient
            .from('products')
            .select('id, unit_price')
            .eq('id', item.product_id)
            .single();

          if (!product) {
            return errorResponse(`Product ${item.product_id} not found`, 404);
          }

          // Use provided unit_price or product's default price
          const unitPrice = item.unit_price ?? product.unit_price;
          totalAmount += unitPrice * item.quantity;
        }

        // Create order
        const { data: order, error: orderError } = await serviceClient
          .from('orders')
          .insert({
            order_number: '', // Will be generated by trigger
            customer_id: body.customer_id,
            warehouse_id: body.warehouse_id,
            total_amount: totalAmount,
            notes: body.notes,
            status: 'pending',
          })
          .select()
          .single();

        if (orderError) throw orderError;

        // Create order items
        const orderItems = body.items.map((item) => ({
          order_id: order.id,
          product_id: item.product_id,
          quantity: item.quantity,
          unit_price: item.unit_price,
        }));

        const { data: items, error: itemsError } = await serviceClient
          .from('order_items')
          .insert(orderItems)
          .select();

        if (itemsError) throw itemsError;

        // Add event to outbox to start the saga
        const sagaPayload = {
          saga_type: 'order_fulfillment',
          order_id: order.id,
          warehouse_id: body.warehouse_id,
          items: body.items.map((item) => ({
            product_id: item.product_id,
            quantity: item.quantity,
            unit_price: item.unit_price,
          })),
        };

        const { error: outboxError } = await serviceClient.rpc('add_outbox_event', {
          p_event_type: 'saga_start',
          p_aggregate_type: 'order',
          p_aggregate_id: order.id,
          p_payload: sagaPayload,
        });

        if (outboxError) {
          console.error('Failed to add outbox event:', outboxError);
          // Order is still created, saga will need manual trigger
        }

        // Trigger saga worker immediately
        try {
          const functionUrl = `${Deno.env.get('SUPABASE_URL')}/functions/v1/saga-worker`;
          await fetch(functionUrl, {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')}`,
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ trigger: 'immediate' }),
          });
        } catch (e) {
          console.error('Failed to trigger saga worker:', e);
          // Non-critical, worker will pick up from outbox
        }

        return jsonResponse(
          {
            ...order,
            items,
            message: 'Order created, fulfillment saga started',
          },
          201
        );
      }

      case 'DELETE': {
        if (!orderId) {
          return errorResponse('Order ID required for cancellation');
        }

        // Get current order status
        const { data: order } = await serviceClient
          .from('orders')
          .select('status')
          .eq('id', orderId)
          .single();

        if (!order) {
          return notFoundResponse('Order');
        }

        // Can only cancel pending orders
        if (!['pending', 'reserved', 'payment_failed'].includes(order.status)) {
          return errorResponse(`Cannot cancel order in ${order.status} status`, 409);
        }

        // Update order status
        const { error: updateError } = await serviceClient
          .from('orders')
          .update({ status: 'cancelled' })
          .eq('id', orderId);

        if (updateError) throw updateError;

        // Get the saga and trigger compensation if needed
        const { data: saga } = await serviceClient
          .from('sagas')
          .select('*')
          .eq('correlation_id', orderId)
          .single();

        if (saga && saga.status !== 'completed' && saga.status !== 'failed') {
          // Trigger compensation
          try {
            const functionUrl = `${Deno.env.get('SUPABASE_URL')}/functions/v1/saga-orchestrator`;
            await fetch(functionUrl, {
              method: 'POST',
              headers: {
                'Authorization': `Bearer ${Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')}`,
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({ saga_id: saga.id, action: 'compensate' }),
            });
          } catch (e) {
            console.error('Failed to trigger compensation:', e);
          }
        }

        return jsonResponse({ message: 'Order cancelled' });
      }

      default:
        return methodNotAllowedResponse();
    }
  } catch (error) {
    console.error('Orders error:', error);
    return errorResponse(error.message || 'Internal server error', 500);
  }
});
