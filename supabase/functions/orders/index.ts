import { Hono } from 'hono';
import { cors } from 'hono/cors';
import { createSupabaseClient, createServiceClient } from '../_shared/supabase-client.ts';
import type { CreateOrderRequest } from '../_shared/types.ts';

type Variables = {
  supabase: ReturnType<typeof createSupabaseClient>;
  serviceClient: ReturnType<typeof createServiceClient>;
};

const app = new Hono<{ Variables: Variables }>().basePath('/orders');

app.use('/*', cors());

// Supabase client middleware
app.use('/*', async (c, next) => {
  c.set('supabase', createSupabaseClient(c.req.raw));
  c.set('serviceClient', createServiceClient()); // For saga operations only
  await next();
});

app.onError((err, c) => {
  console.error('Orders error:', err);
  return c.json({ error: err.message || 'Internal server error' }, 500);
});

// List orders
app.get('/', async (c) => {
  const client = c.get('supabase');

  const status = c.req.query('status');
  const customerId = c.req.query('customer_id');
  const limit = parseInt(c.req.query('limit') || '100');
  const offset = parseInt(c.req.query('offset') || '0');

  let query = client.from('orders').select(
    `
      *,
      warehouse:warehouses(id, code, name)
    `,
    { count: 'exact' }
  );

  if (status) {
    query = query.eq('status', status);
  }
  if (customerId) {
    query = query.eq('customer_id', customerId);
  }

  const { data, error, count } = await query
    .order('created_at', { ascending: false })
    .range(offset, offset + limit - 1);

  if (error) throw error;
  return c.json({ data, count, limit, offset });
});

// Get single order with items and saga status
app.get('/:id', async (c) => {
  const client = c.get('supabase');
  const serviceClient = c.get('serviceClient'); // For saga status lookup
  const id = c.req.param('id');

  const { data: order, error } = await client
    .from('orders')
    .select(`
      *,
      items:order_items(
        id, product_id, quantity, unit_price,
        product:products(id, sku, name)
      ),
      warehouse:warehouses(id, code, name)
    `)
    .eq('id', id)
    .single();

  if (error || !order) {
    return c.json({ error: 'Order not found' }, 404);
  }

  // Get saga status if exists (needs service role - saga tables are internal)
  const { data: saga } = await serviceClient
    .from('sagas')
    .select('id, status, current_step, error_message, created_at, completed_at')
    .eq('correlation_id', id)
    .single();

  return c.json({ ...order, saga: saga || null });
});

// Create order
app.post('/', async (c) => {
  const client = c.get('supabase');
  const serviceClient = c.get('serviceClient'); // For saga operations
  const body: CreateOrderRequest = await c.req.json();

  // Validate required fields
  if (!body.warehouse_id || !body.items || body.items.length === 0) {
    return c.json({ error: 'warehouse_id and at least one item are required' }, 400);
  }

  // Validate warehouse exists
  const { data: warehouse } = await client
    .from('warehouses')
    .select('id')
    .eq('id', body.warehouse_id)
    .single();

  if (!warehouse) {
    return c.json({ error: 'Warehouse not found' }, 404);
  }

  // Validate all products exist and calculate total
  let totalAmount = 0;
  for (const item of body.items) {
    if (!item.product_id || !item.quantity || item.quantity <= 0) {
      return c.json({ error: 'Each item must have product_id and positive quantity' }, 400);
    }

    const { data: product } = await client
      .from('products')
      .select('id, unit_price')
      .eq('id', item.product_id)
      .single();

    if (!product) {
      return c.json({ error: `Product ${item.product_id} not found` }, 404);
    }

    // Use provided unit_price or product's default price
    const unitPrice = item.unit_price ?? product.unit_price;
    totalAmount += unitPrice * item.quantity;
  }

  // Create order
  const { data: order, error: orderError } = await client
    .from('orders')
    .insert({
      order_number: '', // Will be generated by trigger
      customer_id: body.customer_id,
      warehouse_id: body.warehouse_id,
      total_amount: totalAmount,
      notes: body.notes,
      status: 'pending',
    })
    .select()
    .single();

  if (orderError) throw orderError;

  // Create order items
  const orderItems = body.items.map((item) => ({
    order_id: order.id,
    product_id: item.product_id,
    quantity: item.quantity,
    unit_price: item.unit_price,
  }));

  const { data: items, error: itemsError } = await client
    .from('order_items')
    .insert(orderItems)
    .select();

  if (itemsError) throw itemsError;

  // Add event to outbox to start the saga (needs service role - outbox is internal)
  const sagaPayload = {
    saga_type: 'order_fulfillment',
    order_id: order.id,
    warehouse_id: body.warehouse_id,
    items: body.items.map((item) => ({
      product_id: item.product_id,
      quantity: item.quantity,
      unit_price: item.unit_price,
    })),
  };

  const { error: outboxError } = await serviceClient.rpc('add_outbox_event', {
    p_event_type: 'saga_start',
    p_aggregate_type: 'order',
    p_aggregate_id: order.id,
    p_payload: sagaPayload,
  });

  if (outboxError) {
    console.error('Failed to add outbox event:', outboxError);
    // Order is still created, saga will need manual trigger
  }

  // Trigger saga worker immediately
  try {
    const functionUrl = `${Deno.env.get('SUPABASE_URL')}/functions/v1/saga-worker`;
    await fetch(functionUrl, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ trigger: 'immediate' }),
    });
  } catch (e) {
    console.error('Failed to trigger saga worker:', e);
    // Non-critical, worker will pick up from outbox
  }

  return c.json(
    {
      ...order,
      items,
      message: 'Order created, fulfillment saga started',
    },
    201
  );
});

// Cancel order
app.delete('/:id', async (c) => {
  const client = c.get('supabase');
  const serviceClient = c.get('serviceClient'); // For saga operations
  const id = c.req.param('id');

  // Get current order status
  const { data: order } = await client
    .from('orders')
    .select('status')
    .eq('id', id)
    .single();

  if (!order) {
    return c.json({ error: 'Order not found' }, 404);
  }

  // Can only cancel pending orders
  if (!['pending', 'reserved', 'payment_failed'].includes(order.status)) {
    return c.json({ error: `Cannot cancel order in ${order.status} status` }, 409);
  }

  // Update order status
  const { error: updateError } = await client
    .from('orders')
    .update({ status: 'cancelled' })
    .eq('id', id);

  if (updateError) throw updateError;

  // Get the saga and trigger compensation if needed (needs service role - saga tables are internal)
  const { data: saga } = await serviceClient
    .from('sagas')
    .select('*')
    .eq('correlation_id', id)
    .single();

  if (saga && saga.status !== 'completed' && saga.status !== 'failed') {
    // Trigger compensation
    try {
      const functionUrl = `${Deno.env.get('SUPABASE_URL')}/functions/v1/saga-orchestrator`;
      await fetch(functionUrl, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ saga_id: saga.id, action: 'compensate' }),
      });
    } catch (e) {
      console.error('Failed to trigger compensation:', e);
    }
  }

  return c.json({ message: 'Order cancelled' });
});

Deno.serve(app.fetch);
